---
title: C6279 | Microsoft-Dokumentation
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-code-analysis
ms.topic: reference
f1_keywords:
- C6279
helpviewer_keywords:
- C6279
ms.assetid: 0af88b58-35df-456f-8c02-e8eeffe3b7de
caps.latest.revision: 15
author: corob-msft
ms.author: corob
manager: jillfra
ms.openlocfilehash: 3d343438decf92e3b3ea28de77f512b82fc7237a
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/02/2020
ms.locfileid: "77278115"
---
# <a name="c6279"></a>C6279
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Warnung C6279: \<variable> wird mit skalaren New zugeordnet, gelöscht mit Array Delete []  
  
 Diese Warnung wird nur in C++-Code angezeigt und gibt an, dass die aufrufende Funktion Speicher mit dem **New** -Skalaroperator inkonsistent belegt, Sie aber mit dem **delete []** -Array Operator freigegeben hat. Wenn der Arbeitsspeicher mit skalare **New**zugeordnet wird, sollte er in der Regel mit einem skalaren **Lösch**Vorgang freigegeben werden.  
  
 Es gibt mindestens drei Gründe dafür, dass dies Probleme verursacht:  
  
- Die Konstruktoren für die einzelnen Objekte im Array werden – im Gegensatz zu den Destruktoren – nicht aufgerufen.  
  
- Wenn der globale (oder klassenspezifische) **Operator new** und der **Operator Delete** nicht mit dem **Operator new []** und dem **Operator delete []** kompatibel sind, treten wahrscheinlich unerwartete Ergebnisse auf.  
  
  Es ist schwierig, die genauen Auswirkungen dieses Fehlers vorherzusagen. Er kann ein zufälliges Verhalten oder Abstürze verursachen. Beides ist zurückzuführen auf die Verwendung von nicht initialisiertem Speicher, da keine Konstruktoren aufgerufen werden. Oder der Fehler führt zu Speicherbelegungen und Abstürzen in Situationen, in denen Operatoren überschrieben werden. In seltenen Fällen spielt der Konflikt ggf. gar keine Rolle. Derzeit unterscheidet das Analysetool nicht zwischen den beiden Situationen.  
  
## <a name="example"></a>Beispiel  
 Der folgende Code generiert diese Warnung:  
  
```cpp  
class A  
{  
  // members  
};  
  
void f ( )  
{  
  A *pA = new A;  
  //code ...  
  delete[] pA;  
}  
```  
  
 So korrigieren Sie die Warnung unter Verwendung des folgenden Codes  
  
```cpp  
void f( )  
{  
  A *pA = new A;  
  //code ...  
  delete pA;  
}  
```  
  
 Um diese Arten von Speicherbelegungsproblemen vollständig zu vermeiden, verwenden Sie die Mechanismen, die von der C++-Standardvorlagenbibliothek (STL) bereitgestellt werden. Hierzu gehören [shared_ptr](https://msdn.microsoft.com/library/1469fc51-c658-43f1-886c-f4530dd84860), [unique_ptr](https://msdn.microsoft.com/library/acdf046b-831e-4a4a-83aa-6d4ee467db9a)und [Vektor](https://msdn.microsoft.com/library/c1431ad8-c0b6-4dbb-89c4-5f651e432d7f). Weitere Informationen finden Sie unter [intelligente Zeiger](https://msdn.microsoft.com/library/909ef870-904c-49b6-b8cd-e9d0b7dc9435) und [C++-Standard Bibliothek](https://msdn.microsoft.com/library/a37d3ba3-58af-47c7-9ee2-441ccd7b77ee).  
  
## <a name="see-also"></a>Weitere Informationen  
 [C6014](../code-quality/c6014.md)
