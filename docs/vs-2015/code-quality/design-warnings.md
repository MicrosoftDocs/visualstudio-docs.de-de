---
title: Entwurfs Warnungen | Microsoft-Dokumentation
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-code-analysis
ms.topic: conceptual
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design warnings
- managed code analysis warnings, design warnings
- warnings, design
ms.assetid: 34e65a18-560c-423f-814f-519089e318cf
caps.latest.revision: 27
author: jillre
ms.author: jillfra
manager: wpickett
ms.openlocfilehash: 16b44304dbfed49a72a19a15229f3e4754e0573e
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/02/2020
ms.locfileid: "72667660"
---
# <a name="design-warnings"></a>Entwurfswarnungen
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Entwurfs Warnungen unterstützen die Einhaltung der .NET Framework Entwurfs Richtlinien.

## <a name="in-this-section"></a>In diesem Abschnitt

|Regel|Beschreibung|
|----------|-----------------|
|[CA1000: Statische Member nicht in generischen Typen deklarieren.](../code-quality/ca1000-do-not-declare-static-members-on-generic-types.md)|Wenn ein statischer Member eines generischen Typs aufgerufen wird, muss das Typargument für den Typ angegeben werden. Wenn ein generischer Instanzmember, der keine Unterstützung für Rückschlüsse bietet, aufgerufen wird, muss das Typargument für den Member angegeben werden. In diesen beiden Fällen ist die Syntax zum Angeben des Typarguments unterschiedlich und leicht zu verwechseln.|
|[CA1001: Typen, die löschbare Felder besitzen, müssen gelöscht werden können.](../code-quality/ca1001-types-that-own-disposable-fields-should-be-disposable.md)|Eine Klasse deklariert und implementiert ein Instanzfeld, das ein System. iverwerfbarer Typ ist, und die Klasse implementiert iverwerfnicht. Eine Klasse, die ein IDisposable-Feld deklariert, besitzt indirekt eine nicht verwaltete Ressource und sollte die IDisposable-Schnittstelle implementieren.|
|[CA1002: Generische Listen nicht verfügbar machen.](../code-quality/ca1002-do-not-expose-generic-lists.md)|System. Collections. Generic. List< (of \<(T> ) >) ist eine generische Sammlung, die für Leistung und nicht Vererbung konzipiert ist. Daher enthält List keine virtuellen Member. Stattdessen sollten die generischen Auflistungen, die im Hinblick auf die Vererbung entworfen wurden, verfügbar gemacht werden.|
|[CA1003: Generische Ereignishandlerinstanzen verwenden.](../code-quality/ca1003-use-generic-event-handler-instances.md)|Ein Typ enthält einen Delegaten, der "void" zurückgibt, dessen Signatur zwei Parameter enthält (das erste Objekt und das zweite einen Typ, der EventArgs zugewiesen werden kann) und die enthaltenden Assembly-Ziele [!INCLUDE[dnprdnlong](../includes/dnprdnlong-md.md)] .|
|[CA1004: Generische Methoden müssen den Typparameter angeben.](../code-quality/ca1004-generic-methods-should-provide-type-parameter.md)|Mithilfe eines Rückschlusses wird das Typargument einer generischen Methode nach dem Typ des an die Methode übergebenen Arguments festgelegt, anstatt nach der expliziten Spezifikation des Typarguments. Um den Rückschluss zu aktivieren, muss die Parametersignatur einer generischen Methode einen Parameter einschließen, der vom selben Typ wie der Typparameter für die Methode ist. In diesem Fall muss das Typargument nicht angegeben werden. Wenn Sie den Rückschluss für alle Typparameter verwenden, ist die Syntax zum Aufrufen von generischen und nicht generischen Instanzmethoden identisch. Dies vereinfacht die Verwendbarkeit generischer Methoden.|
|[CA1005: Übermäßige Anzahl von Parametern in generischen Typen vermeiden.](../code-quality/ca1005-avoid-excessive-parameters-on-generic-types.md)|Je mehr Typparameter ein generischer Typ enthält, desto schwieriger ist es, zu wissen und zu behalten, was die einzelnen Typparameter darstellen. Es ist in der Regel offensichtlich mit einem Typparameter, wie in der Liste \<T> , und in bestimmten Fällen mit zwei Typparametern, wie im Wörterbuch \<TKey, TValue> . Mehr als zwei Typparameter hingegen bereiten den meisten Benutzern Schwierigkeiten.|
|[CA1006: Generische Typen in Membersignaturen nicht schachteln.](../code-quality/ca1006-do-not-nest-generic-types-in-member-signatures.md)|Ein geschachteltes Typargument ist ein Typargument, das auch ein generischer Typ ist. Um einen Member aufzurufen, dessen Signatur ein geschachteltes Typargument enthält, muss der Benutzer einen generischen Typ instanziieren und diesen an den Konstruktor eines zweiten generischen Typs übergeben. Die erforderliche Prozedur und die Syntax sind komplex, und diese Vorgehensweise sollte daher vermieden werden.|
|[CA1007: Nach Möglichkeit Generics verwenden.](../code-quality/ca1007-use-generics-where-appropriate.md)|Eine extern sichtbare Methode enthält einen Verweisparameter vom Typ System.Object. Bei Verwendung einer generischen Methode können alle Typen mit gewissen Einschränkungen an die Methode übergeben werden, ohne dass der Typ zuvor in den Typ des Verweisparameters umgewandelt werden muss.|
|[CA1008: Enumerationen müssen einen Wert von 0 (null) aufweisen.](../code-quality/ca1008-enums-should-have-zero-value.md)|Der Standardwert einer nicht initialisierten Enumeration ist ebenso wie der anderer Werttypen 0 (null). Eine nicht-Flags-Enumeration sollte einen Member mit dem Wert 0 (null) definieren, sodass der Standardwert ein gültiger Wert der-Enumeration ist. Wenn eine Enumeration, auf die FlagsAttribute angewendet wird, einen Member mit dem Wert 0 (null) definiert, sollte dieser den Namen "None" haben, um anzugeben, dass in der Enumeration keine Werte festgelegt wurden.|
|[CA1009: Ereignishandler korrekt deklarieren.](../code-quality/ca1009-declare-event-handlers-correctly.md)|Ereignishandlermethoden nehmen zwei Parameter an. Der erste ist vom Typ System.Object und hat den Namen "sender". Dies ist das Objekt, durch das das Ereignis ausgelöst wurde. Der zweite Parameter ist vom Typ System.EventArgs und hat den Namen "e". Dies sind die Daten, die dem Ereignis zugeordnet sind. Ereignishandlermethoden geben normalerweise keinen Wert zurück. In der Programmiersprache C# wird dies mit dem void-Rückgabetyp angegeben.|
|[CA1010: Sammlungen müssen eine generische Schnittstelle implementieren.](../code-quality/ca1010-collections-should-implement-generic-interface.md)|Um die Verwendbarkeit einer Auflistung zu erweitern, implementieren Sie eine der generischen Auflistungsschnittstellen. Anschließend kann die Auflistung zum Auffüllen generischer Auflistungstypen verwendet werden.|
|[CA1011: Basistypen als Parameter übergeben.](../code-quality/ca1011-consider-passing-base-types-as-parameters.md)|Wenn in einer Methodendeklaration ein Basistyp als Parameter angegeben wird, kann jeder Typ, der von diesem Basistyp abgeleitet ist, als entsprechendes Argument an die Methode übergeben werden. Wenn die vom abgeleiteten Parametertyp bereitgestellte zusätzliche Funktionalität nicht erforderlich ist, lässt die Verwendung des Basistyps eine allgemeinere Nutzung der Methode zu.|
|[CA1012: Abstrakte Typen dürfen keine Konstruktoren aufweisen.](../code-quality/ca1012-abstract-types-should-not-have-constructors.md)|Konstruktoren von abstrakten Datentypen können nur von abgeleiteten Typen aufgerufen werden. Da öffentliche Konstruktoren Instanzen eines Typs erstellen und Sie keine Instanzen eines abstrakten Datentyps erstellen können, ist ein abstrakter Datentyp mit einem öffentlichen Konstruktor fehlerhaft konzipiert.|
|[CA1013: Gleichheitsoperator beim Überladen von Addition und Subtraktion überladen.](../code-quality/ca1013-overload-operator-equals-on-overloading-add-and-subtract.md)|Ein öffentlicher oder geschützter Typ implementiert den Additions- oder Subtraktionsoperator, ohne den Gleichheitsoperator zu implementieren.|
|[CA1014: Assemblys mit CLSCompliantAttribute markieren.](../code-quality/ca1014-mark-assemblies-with-clscompliantattribute.md)|In der Common Language Specification (CLS) sind Benennungseinschränkungen, Datentypen und Regeln definiert, denen Assemblys entsprechen müssen, wenn sie in verschiedenen Programmiersprachen verwendet werden sollen. Ein guter Entwurf bedeutet, dass alle Assemblys mit CLSCompliantAttribute explizit die CLS-Konformität angeben. Wenn das Attribut in einer Assembly nicht vorhanden ist, ist die Assembly nicht kompatibel.|
|[CA1016: Assemblys mit AssemblyVersionAttribute markieren.](../code-quality/ca1016-mark-assemblies-with-assemblyversionattribute.md)|Der .NET Framework verwendet die Versionsnummer zur eindeutigen Identifizierung einer Assembly und zum Binden an Typen in Assemblys mit starkem Namen. Die Versionsnummer wird zusammen mit der Versions- und Herausgeberrichtlinie verwendet. Standardmäßig werden Anwendungen nur mit der Assemblyversion ausgeführt, mit der sie erstellt wurden.|
|[CA1017: Assemblys mit ComVisibleAttribute markieren.](../code-quality/ca1017-mark-assemblies-with-comvisibleattribute.md)|Das ComVisibleAttribute-Attribut bestimmt, wie COM-Clients auf verwalteten Code zugreifen. Gute Entwurfsprinzipien verlangen, dass die COM-Sichtbarkeit durch Assemblys explizit angegeben wird. Die COM-Sichtbarkeit kann für die gesamte Assembly festgelegt und anschließend für einzelne Typen und Typmember überschrieben werden. Wenn das Attribut fehlt, ist der Inhalt der Assembly für COM-Clients sichtbar.|
|[CA1018: Attribute mit AttributeUsageAttribute markieren.](../code-quality/ca1018-mark-attributes-with-attributeusageattribute.md)|Wenn Sie ein benutzerdefiniertes Attribut definieren, markieren Sie es mithilfe von AttributeUsageAttribute, um anzugeben, an welcher Stelle im Quellcode das benutzerdefinierte Attribut angewendet werden kann. Die Bedeutung und die beabsichtigte Verwendung eines Attributs bestimmen die gültigen Positionen des Attributs im Code.|
|[CA1019: Accessoren für Attributargumente definieren.](../code-quality/ca1019-define-accessors-for-attribute-arguments.md)|Attribute können obligatorische Argumente definieren, die angegeben werden müssen, wenn das Attribut auf ein Ziel angewendet wird. Diese Argumente werden auch als positionelle Argumente bezeichnet, da sie bei Attributkonstruktoren als positionelle Parameter angegeben werden. Für jedes obligatorische Argument muss das Attribut außerdem eine entsprechende schreibgeschützte Eigenschaft enthalten, damit der Wert des Arguments zur Ausführungszeit abgerufen werden kann. Attribute können auch optionale Argumente definieren, die auch als benannte Argumente bezeichnet werden. Diese Argumente werden bei Attributkonstruktoren über ihren Namen angegeben und sollten über eine entsprechende Lese-Schreib-Eigenschaft verfügen.|
|[CA1020: Namespaces mit wenigen Typen vermeiden.](../code-quality/ca1020-avoid-namespaces-with-few-types.md)|Stellen Sie sicher, dass jeder Ihrer Namespaces über eine logische Organisation verfügt und dass Sie einen gültigen Grund haben, um Typen in einen spärlich aufgefüllten Namespace einzufügen.|
|[CA1021: out-Parameter vermeiden.](../code-quality/ca1021-avoid-out-parameters.md)|Die Übergabe von Typen als Verweis (mit out oder ref) erfordert Erfahrung im Umgang mit Zeigern, Kenntnisse der Unterschiede zwischen Wert- und Verweistypen und Erfahrung im Umgang mit Methoden mit mehreren Rückgabewerten. Außerdem ist der Unterschied zwischen dem out-Parameter und dem ref-Parametern oft unklar.|
|[CA1023: Indexer sollten nicht mehrdimensional sein.](../code-quality/ca1023-indexers-should-not-be-multidimensional.md)|Indexer, d. h. indizierte Eigenschaften, sollten einen einzelnen Index verwenden. Wegen mehrdimensionaler Indexer kann die Verwendbarkeit der Bibliothek deutlich abnehmen.|
|[CA1024: Nach Möglichkeit Eigenschaften verwenden.](../code-quality/ca1024-use-properties-where-appropriate.md)|Eine öffentliche oder geschützte Methode hat einen Namen, der mit "Get" beginnt. Sie nimmt keine Parameter an und gibt einen Wert zurück, bei dem es sich nicht um ein Array handelt. Die Methode ist möglicherweise als Eigenschaft geeignet.|
|[CA1025: Sich wiederholende Argumente durch ein Parameterarray ersetzen.](../code-quality/ca1025-replace-repetitive-arguments-with-params-array.md)|Verwenden Sie ein Parameterarray statt sich wiederholender Argumente, wenn die genaue Anzahl der Argumente nicht bekannt ist und diese Argumente vom gleichen Typ sind oder als gleicher Typ übergeben werden können.|
|[CA1026: Standardparameter sollten nicht verwendet werden.](../code-quality/ca1026-default-parameters-should-not-be-used.md)|Methoden, die Standardparameter verwenden, sind nach der CLS zulässig. Die CLS lässt jedoch zu, dass die Werte, die diesen Parametern zugewiesen sind, von Compilern ignoriert werden. Damit das gewünschte Verhalten in verschiedenen Programmiersprachen erhalten bleibt, müssen Methoden, die Standardparameter verwenden, durch Methodenüberladungen ersetzt werden, von denen die Standardparameter bereitgestellt werden.|
|[CA1027: Enumerationen mit FlagsAttribute markieren.](../code-quality/ca1027-mark-enums-with-flagsattribute.md)|Eine Enumeration ist ein Werttyp, der einen Satz verwandter benannter Konstanten definiert. Wenden Sie FlagsAttribute auf eine Enumeration an, wenn deren benannte Konstanten sinnvoll kombiniert werden können.|
|[CA1028: Der Enumerationsspeicher sollte Int32 sein.](../code-quality/ca1028-enum-storage-should-be-int32.md)|Eine Enumeration ist ein Werttyp, der einen Satz verwandter benannter Konstanten definiert. Standardmäßig wird zum Speichern des konstanten Werts der System.Int32-Datentyp verwendet. Obwohl Sie diesen zugrunde liegenden Typ ändern können, ist er in den meisten Szenarien nicht erforderlich oder nicht empfehlenswert.|
|[CA1030: Nach Möglichkeit Ereignisse verwenden.](../code-quality/ca1030-use-events-where-appropriate.md)|Diese Regel erkennt Methoden, deren Namen normalerweise für Ereignisse verwendet würden. Wenn eine Methode auf eine klar definierte Zustandsänderung hin aufgerufen wird, sollte die Methode von einem Ereignishandler aufgerufen werden. Objekte, die die Methode aufrufen, sollten Ereignisse auslösen, statt die Methode direkt aufzurufen.|
|[CA1031: Allgemeine Ausnahmetypen nicht auffangen.](../code-quality/ca1031-do-not-catch-general-exception-types.md)|Allgemeine Ausnahmen sollten nicht abgefangen werden. Fangen Sie eine spezifischere Ausnahme ab, oder lösen Sie die allgemeine Ausnahme erneut als letzte Anweisung im catch-Block aus.|
|[CA1032: Standardausnahmekonstruktoren implementieren.](../code-quality/ca1032-implement-standard-exception-constructors.md)|Falls nicht der vollständige Satz von Konstruktoren angegeben wird, wird eine ordnungsgemäße Behandlung von Ausnahmen unter Umständen erschwert.|
|[CA1033: Schnittstellenmethoden sollten von untergeordneten Typen aufgerufen werden können.](../code-quality/ca1033-interface-methods-should-be-callable-by-child-types.md)|Ein unversiegelter, extern sichtbarer Typ gibt eine explizite Methodenimplementierung einer öffentlichen Schnittstelle an und gibt keine alternative extern sichtbare Methode mit dem gleichen Namen an.|
|[CA1034: Geschachtelte Typen sollten nicht sichtbar sein.](../code-quality/ca1034-nested-types-should-not-be-visible.md)|Ein geschachtelter Typ ist ein Typ, der innerhalb des Gültigkeitsbereichs eines anderen Typs deklariert ist. Geschachtelte Typen eignen sich für die Kapselung privater Implementierungsdetails der enthaltenden Typen. Bei dieser Verwendungsart sollten geschachtelte Typen nicht extern sichtbar sein.|
|[CA1035: ICollection-Implementierungen weisen Member mit starker Typisierung auf.](../code-quality/ca1035-icollection-implementations-have-strongly-typed-members.md)|Nach dieser Regel müssen ICollection-Implementierungen stark typisierte Member angeben, damit die Benutzer keine Argumente in den Object-Typ umwandeln müssen, wenn sie die durch die Schnittstelle zur Verfügung gestellten Funktionen verwenden. Diese Regel geht davon aus, dass der Typ, der ICollection implementiert, diese Implementierung zur Verwaltung einer Auflistung von Instanzen eines Typs vornimmt, der stärker ist als Object.|
|[CA1036: Methoden bei vergleichbaren Typen überschreiben.](../code-quality/ca1036-override-methods-on-comparable-types.md)|Ein öffentlicher oder geschützter Typ implementiert die System.IComparable-Schnittstelle. Er überschreibt Object.Equals nicht und überlädt auch nicht den sprachspezifischen Operator für gleich, ungleich, kleiner als und größer als.|
|[CA1038: Enumeratoren sollten eine starke Typisierung aufweisen.](../code-quality/ca1038-enumerators-should-be-strongly-typed.md)|Nach dieser Regel müssen IEnumerator-Implementierungen für die Current-Eigenschaft auch eine Version mit starker Typisierung angeben, damit die Benutzer den Rückgabewert nicht in den starken Typ umwandeln müssen, wenn sie die durch die Schnittstelle zur Verfügung gestellten Funktionen verwenden.|
|[CA1039: Listen weisen eine starke Typisierung auf.](../code-quality/ca1039-lists-are-strongly-typed.md)|Nach dieser Regel müssen IList-Implementierungen stark typisierte Member angeben, damit die Benutzer keine Argumente in den System.Object-Typ umwandeln müssen, wenn sie die durch die Schnittstelle zur Verfügung gestellten Funktionen verwenden.|
|[CA1040: Leere Schnittstellen vermeiden.](../code-quality/ca1040-avoid-empty-interfaces.md)|Schnittstellen definieren Member, die ein Verhalten oder einen Verwendungsvertrag bereitstellen. Die durch die Schnittstelle beschriebene Funktionalität kann von jedem Typ übernommen werden, unabhängig davon, an welcher Stelle der Typ in der Vererbungshierarchie steht. Ein Typ implementiert eine Schnittstelle, indem er Implementierungen für die Member der Schnittstelle bereitstellt. Eine leere Schnittstelle definiert keine Member. Daher definiert sie keinen Vertrag, der implementiert werden kann.|
|[CA1041: ObsoleteAttribute-Meldung bereitstellen.](../code-quality/ca1041-provide-obsoleteattribute-message.md)|Ein Typ oder Member wird mit einem System.ObsoleteAttribute-Attribut markiert, dessen ObsoleteAttribute.Message-Eigenschaft nicht angegeben wurde. Wenn ein Typ oder Member, der mithilfe von ObsoleteAttribute markiert ist, kompiliert wird, wird die Message-Eigenschaft des Attributs angezeigt, die dem Benutzerinformationen über den veralteten Typ oder Member übergibt.|
|[CA1043: Ganzzahliges Argument oder Zeichenfolgenargument für Indexer verwenden.](../code-quality/ca1043-use-integral-or-string-argument-for-indexers.md)|Indexer (d. h. indizierte Eigenschaften) sollten ganzzahlige Typen oder Zeichenfolgentypen für den Index verwenden. Diese Typen werden i. d. R. zum Indizieren von Datenstrukturen verwendet und erweitern den Einsatzbereich der Bibliothek. Die Verwendung des Object-Typs sollte auf die Fälle beschränkt werden, in denen der spezielle integrale oder Zeichenfolgentyp zur Entwurfszeit nicht angegeben werden kann.|
|[CA1044: Eigenschaften sollten nicht lesegeschützt sein.](../code-quality/ca1044-properties-should-not-be-write-only.md)|Obwohl eine schreibgeschützte Eigenschaft akzeptabel und oft erforderlich ist, verhindern die Entwurfsrichtlinien die Verwendung von Eigenschaften, die nur geschrieben werden können. Wenn ein Benutzer einen Wert festlegen kann, bietet es keinerlei Sicherheitsvorteile, das Lesen und Anzeigen des Werts durch den Benutzer zu sperren. Außerdem kann der Zustand freigegebener Objekte ohne Lesezugriff nicht angezeigt werden, wodurch ihre Nützlichkeit eingeschränkt wird.|
|[CA1045: Typen nicht als Verweis übergeben.](../code-quality/ca1045-do-not-pass-types-by-reference.md)|Die Übergabe von Typen als Verweis (mit out oder ref) erfordert Erfahrung im Umgang mit Zeigern, Kenntnisse der Unterschiede zwischen Wert- und Verweistypen und Erfahrung im Umgang mit Methoden mit mehreren Rückgabewerten. Entwickler von Bibliotheken für eine breite Zielgruppe sollten nicht davon ausgehen, dass die Benutzer den out-Parameter oder den ref-Parameter richtig verwenden können.|
|[CA1046: Gleichheitsoperator für Referenztypen nicht überladen.](../code-quality/ca1046-do-not-overload-operator-equals-on-reference-types.md)|Für Verweistypen ist die Standardimplementierung des Gleichheitsoperators fast immer zutreffend. Standardmäßig sind zwei Verweise nur dann gleich, wenn sie auf dasselbe Objekt zeigen.|
|[CA1047: Geschützte Member in versiegelten Typen nicht deklarieren.](../code-quality/ca1047-do-not-declare-protected-members-in-sealed-types.md)|Typen deklarieren geschützte Member, damit erbende Typen auf den Member zugreifen oder diesen überschreiben können. Per Definition kann von versiegelten Typen nicht geerbt werden. Dies bedeutet, dass geschützte Methoden für versiegelte Typen nicht aufgerufen werden können.|
|[CA1048: Virtuelle Member in versiegelten Typen nicht deklarieren.](../code-quality/ca1048-do-not-declare-virtual-members-in-sealed-types.md)|Typen deklarieren Methoden als virtuell, damit erbende Typen die Implementierung der virtuellen Methode überschreiben können. Per Definition kann ein versiegelter Typ nicht geerbt werden. Dadurch wird eine virtuelle Methode für einen versiegelten Typ bedeutungslos.|
|[CA1049: Typen, die native Ressourcen besitzen, müssen gelöscht werden können.](../code-quality/ca1049-types-that-own-native-resources-should-be-disposable.md)|Typen, die nicht verwaltete Ressourcen zuordnen, müssen IDisposable implementieren, damit Aufrufer diese Ressourcen bei Bedarf freigeben und die Lebensdauer der Objekte verkürzen können, die diese Ressourcen verwenden.|
|[CA1050: Typen in Namespaces deklarieren.](../code-quality/ca1050-declare-types-in-namespaces.md)|Typen werden in Namespaces deklariert, um Namenskonflikte zu verhindern und um verwandte Typen in einer Objekthierarchie zu organisieren.|
|[CA1051: Sichtbare Instanzfelder nicht deklarieren.](../code-quality/ca1051-do-not-declare-visible-instance-fields.md)|Ein Feld sollte primär als Implementierungsdetail verwendet werden. Felder sollten privat oder intern sein und durch die Verwendung von Eigenschaften verfügbar gemacht werden.|
|[CA1052: Statische Haltertypen sollten versiegelt sein.](../code-quality/ca1052-static-holder-types-should-be-sealed.md)|Ein öffentlicher oder geschützter Typ enthält nur statische Member und wird nicht mit dem sealed (c#)-oder notvererable (Visual Basic)-Modifizierer deklariert. Ein Typ, der nicht geerbt werden soll, sollte mit dem sealed-Modifizierer markiert werden, um seine Verwendung als Basistyp zu verhindern.|
|[CA1053: Statische Haltertypen sollten keine Konstruktoren aufweisen.](../code-quality/ca1053-static-holder-types-should-not-have-constructors.md)|Ein öffentlicher oder verschachtelter öffentlicher Typ deklariert nur statische Member und verfügt über einen öffentlichen oder geschützten Standardkonstruktor. Der Konstruktor ist überflüssig, da zum Aufrufen statischer Member keine Instanz des Typs erforderlich ist. Die Zeichenfolgenüberladung sollte die URI-Überladung aus Sicherheitsgründen mit dem Zeichenfolgenargument aufrufen.|
|[CA1054: URI-Parameter dürfen keine Zeichenfolgen sein.](../code-quality/ca1054-uri-parameters-should-not-be-strings.md)|Wenn eine Methode eine Zeichenfolgendarstellung eines URIs annimmt, sollte eine entsprechende Überladung angegeben werden, die eine Instanz der URI-Klasse annimmt, die diese Dienste auf sichere Weise bereitstellt.|
|[CA1055: URI-Rückgabewerte dürfen keine Zeichenfolgen sein.](../code-quality/ca1055-uri-return-values-should-not-be-strings.md)|Diese Regel geht davon aus, dass die Methode einen URI zurückgibt. Eine Zeichenfolgendarstellung eines URIs ist anfällig für Analyse- und Codierungsfehler und kann zu Sicherheitsmängeln führen. Die System.Uri-Klasse stellt diese Dienste auf sichere Weise bereit.|
|[CA1056: URI-Eigenschaften dürfen keine Zeichenfolgen sein.](../code-quality/ca1056-uri-properties-should-not-be-strings.md)|Diese Regel setzt voraus, dass die-Eigenschaft einen URI darstellt. Eine Zeichenfolgendarstellung eines URIs ist anfällig für Analyse- und Codierungsfehler und kann zu Sicherheitsmängeln führen. Die System.Uri-Klasse stellt diese Dienste auf sichere Weise bereit.|
|[CA1057: URI-Überladungen vom Typ string rufen Überladungen vom Typ System.Uri auf.](../code-quality/ca1057-string-uri-overloads-call-system-uri-overloads.md)|Ein Typ deklariert Methodenüberladungen, die sich nur durch die Ersetzung eines Zeichenfolgenparameters mit einem System.Uri-Parameter unterscheiden. Die Überladung, die den Zeichenfolgenparameter akzeptiert, ruft nicht die Überladung auf, die den URI-Parameter akzeptiert.|
|[CA1058: Typen sollten bestimmte Basistypen nicht erweitern.](../code-quality/ca1058-types-should-not-extend-certain-base-types.md)|Ein extern sichtbarer Typ erweitert bestimmte Basistypen. Verwenden Sie eine der Alternativen.|
|[CA1059: Member sollten bestimmte konkrete Typen nicht verfügbar machen.](../code-quality/ca1059-members-should-not-expose-certain-concrete-types.md)|Ein konkreter Typ ist ein Typ, der eine vollständige Implementierung aufweist und deshalb instanziiert werden kann. Damit der Member universell verwendet werden kann, ersetzen Sie den konkreten Typ durch die vorgeschlagene Schnittstelle.|
|[CA1060: P/Aufrufe in die NativeMethods-Klasse verschieben](../code-quality/ca1060-move-p-invokes-to-nativemethods-class.md)|Platt Form Aufruf Methoden, z. b. solche, die mit der-Methode oder der-Methode gekennzeichnet sind <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> , die mit dem Declare-Schlüsselwort in definiert [!INCLUDE[vbprvb](../includes/vbprvb-md.md)] wurden, greifen Diese Methoden sollten der Klasse NativeMethods, SafeNativeMethods oder UnsafeNativeMethods angehören.|
|[CA1061: Basisklassenmethoden nicht ausblenden.](../code-quality/ca1061-do-not-hide-base-class-methods.md)|Eine Methode in einem Basistyp wird durch eine Methode mit identischem Namen in einem abgeleiteten Typ verdeckt, wenn die Parametersignatur der abgeleiteten Methode sich nur hinsichtlich der Typen unterscheidet, die schwächer abgeleitet sind als die entsprechenden Typen in der Parametersignatur der Basismethode.|
|[CA1062: Argumente von öffentlichen Methoden validieren.](../code-quality/ca1062-validate-arguments-of-public-methods.md)|Alle an extern sichtbare Methoden übergebenen Verweisargumente sollten auf NULL überprüft werden.|
|[CA1063: IDisposable korrekt implementieren.](../code-quality/ca1063-implement-idisposable-correctly.md)|Alle IDisposable-Typen müssen das Dispose-Muster korrekt implementieren.|
|[CA1064: Ausnahmen sollten öffentlich sein.](../code-quality/ca1064-exceptions-should-be-public.md)|Eine interne Ausnahme ist nur innerhalb ihres eigenen internen Bereichs sichtbar. Nachdem die Ausnahme den internen Bereich verlassen hat, kann nur die Basisausnahme zum Abfangen der Ausnahme verwendet werden. Wenn die interne Ausnahme von <xref:System.Exception?displayProperty=fullName> , oder geerbt wird <xref:System.SystemException?displayProperty=fullName> <xref:System.ApplicationException?displayProperty=fullName> , verfügt der externe Code nicht über genügend Informationen, um zu wissen, was mit der Ausnahme zu tun ist.|
|[CA1065: Keine Ausnahmen an unerwarteten Speicherorten auslösen.](../code-quality/ca1065-do-not-raise-exceptions-in-unexpected-locations.md)|Eine Methode, von der das Auslösen von Ausnahmen nicht erwartet wird, löst eine Ausnahme aus.|
|[CA2210: Assemblys müssen gültige starke Namen aufweisen.](../code-quality/ca2210-assemblies-should-have-valid-strong-names.md)|Der starke Name schützt Clients vor dem versehentlichen Laden einer manipulierten Assembly. Assemblys ohne starke Namen sollten nur in ganz bestimmten Szenarien bereitgestellt werden. Wenn Sie nicht einwandfrei signierte Assemblys freigeben oder verteilen, kann die Assembly manipuliert werden, die Common Language Runtime lädt die Assembly unter Umständen nicht, oder der Benutzer muss die Überprüfung auf dem Computer deaktivieren.|
